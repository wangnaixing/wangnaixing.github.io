<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangnaixing</title>
  
  <subtitle>@Navy81</subtitle>
  <link href="https://wangnaixing.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangnaixing.github.io/"/>
  <updated>2021-12-05T09:40:50.138Z</updated>
  <id>https://wangnaixing.github.io/</id>
  
  <author>
    <name>wnx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>了解这些软件设计思想，你的思维至少上升一个段位！</title>
    <link href="https://wangnaixing.github.io/2021/12/07/%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%80%9D%E7%BB%B4%E8%87%B3%E5%B0%91%E4%B8%8A%E5%8D%87%E4%B8%80%E4%B8%AA%E6%AE%B5%E4%BD%8D%EF%BC%81/"/>
    <id>https://wangnaixing.github.io/2021/12/07/%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%80%9D%E7%BB%B4%E8%87%B3%E5%B0%91%E4%B8%8A%E5%8D%87%E4%B8%80%E4%B8%AA%E6%AE%B5%E4%BD%8D%EF%BC%81/</id>
    <published>2021-12-07T01:25:00.000Z</published>
    <updated>2021-12-05T09:40:50.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解这些软件设计思想，你的思维至少上升一个段位！"><a href="#了解这些软件设计思想，你的思维至少上升一个段位！" class="headerlink" title="了解这些软件设计思想，你的思维至少上升一个段位！"></a>了解这些软件设计思想，你的思维至少上升一个段位！</h1><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念，四位作者合称 GOF（全拼 Gang of Four），简称四人帮！</p><blockquote><p>书中共说到 23 种设计模式，这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p></blockquote><p>当然，随着软件的快速发展，还出现另一类我们所熟知的设计模式：<strong>J2EE 设计模式</strong>。</p><p>首先要跟大家说明的是，<strong>设计模式其实不是一项新技术</strong>，而是众多软件开发人员经过相当长的一段时间的试用和试错总结出来的一套软件设计开发实践方案，学习这些知识有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p><p>也不BB了，下面我们就一起来深入了解一下大神们总结的这套方法论！</p><h3 id="二、方法论"><a href="#二、方法论" class="headerlink" title="二、方法论"></a>二、方法论</h3><h4 id="2-1、单一职责原则"><a href="#2-1、单一职责原则" class="headerlink" title="2.1、单一职责原则"></a>2.1、单一职责原则</h4><p>单一职责原则，顾名思义，一个类负责一个功能的处理，比如我们在代码中经常会涉及到调用第三方的接口，通常我们往往会将一个接口请求方法封装成一个<code>http</code>请求的工具类，这样其他的调用方能非常方便的进行调用。</p><p>单一职责原则，主要的目的是将一个功能划分到合适的粒度，让这些各自执行单一职责的类，各司其职。</p><p>还有我们常常说的mvc模式，将数据操作与业务逻辑处理进行分离，也是属于单一职责原则的一种。</p><h4 id="2-2、开闭原则"><a href="#2-2、开闭原则" class="headerlink" title="2.2、开闭原则"></a>2.2、开闭原则</h4><p>开闭原则，指的是：<strong>对扩展开放，对修改关闭</strong>。这里的意思是在增加新功能的时候，<strong>能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的</strong>。</p><p>下面我举个简单的例子，大家可能就懂了。</p><p>在实际的项目开发过程中，尤其是与第三方公司进行接口对接的时候，例如 a 公司，他的接口协议要求采用<code>rsa</code>加密；b 公司，他的接口协议采用<code>aes</code>加密，c公司，他的接口协议要求采用<code>md5</code>就可以了…</p><p>在一开始的时候，可能你没有想那么多，设想所有其他公司跟你对接的时候，全部采用<code>rsa</code>加密，那么当第二家公司来了时候，要求采用<code>aes</code>，这个时候，你必须得改代码才能支持这种功能，假如又来了其他公司呢？</p><p>在这种情况下，我们可以采用面向接口编程的思想，定义一个抽象的方法，然后针对不同的加密算法，编写不同的实现类，当新来了一家公司要求采用不同的加密算法时，我们只需要扩展一个新的实现类，在逻辑处理层进行路由即可快速完成开发和对接！</p><p>实现开闭原则的主要步骤就是将业务方法里面的逻辑进行抽象化，从而实现逻辑层面代码的解耦。</p><h4 id="2-3、里氏代换原则"><a href="#2-3、里氏代换原则" class="headerlink" title="2.3、里氏代换原则"></a>2.3、里氏代换原则</h4><p>里氏替换原则，通俗的说就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</p><p>也就是说：<strong>子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法</strong>。</p><p>当子类在重写父类的方法时，如果使用不当，很可能会改变父类方法中的逻辑语义，进而造成逻辑处理混乱。</p><p>在实际的业务开发中，尤其是大家在使用类继承操作时，应当谨慎重新父类方法，方法定义的时候，名称也尽量不要发生重名。</p><p>同时，应该注意类过多的继承，例如 A 类继承自 B 类，B 类 继承自 C 类，C 类继承 D 类，这种场景下，第一：逻辑很可能非常复杂，代码可读性可能很差，第二种可能会出现方法名或者属性名冲突。</p><p>我曾经修改一个老项目 bug 的时候，就出现过这种情况，一个实体类出现三层关系的继承，当我把子类进行序列化成<code>json</code>的时候，突然报错，原因就是因为里面有个属性，在基类里面也定义了，但是类型却不一样，也就是说在这个子类里面有两个相同的属性，只是字段类型不同而已，从而导致这个序列化报错。</p><p>因此，大家在使用类继承操作时，一定要谨慎处理，最好的情况下是一层关系继承，这样即使出现问题了，也好排查，范围可控；继承关系多了，反而代码变的非常复杂，每个方法逻辑都需要一一梳理清楚，你才敢去下手，这种情况下，反而为难了自己！</p><h4 id="2-4、依赖倒转原则"><a href="#2-4、依赖倒转原则" class="headerlink" title="2.4、依赖倒转原则"></a>2.4、依赖倒转原则</h4><p>依赖倒转原则，简单的说就是<strong>面向接口编程，依赖于抽象而不依赖于具体</strong>，他是实现<strong>开闭原则</strong>的一个途径。</p><p>依赖倒转原则主要有以下几点：</p><ul><li>高层的模块不应该依赖于低层的模块，这两者都应该依赖于其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p>换句话说，就是将具体类里面的方法进行逻辑抽象化，提升到接口或者抽象类里面，由具体的实现类去实现具体的业务逻辑，抽象层不关注细节。</p><p>也就是我们俗称的，不管遇到啥事情，先看大局，在看小点。</p><p>举个例子，例如我们常常使用的<code>MVC</code>框架，在<code>Service</code>层通常会<strong>先编写接口类，然后在编写服务实现类，这就是典型的面向接口编程</strong>，这种方案有哪些好处呢？</p><ul><li>可以减少研发人员并行开发引起的风险</li><li>可以显著提高代码的可读性和可维护性</li><li>可以降低类间的耦合性</li></ul><p>当一个大项目开发的时候，试想一下，如果2个以上研发人员在编写同一个类的同一个方法，没有定义接口的情况下，随着时间的流逝，这个类大概率会非常混乱，同时，里面的方法估计阅读起来也很困难，一眼望去基本上不知道这个方法是干嘛的，尤其是重载方法很多的时候，尤其困难。</p><p>当我们引入接口之后，将所有的核心方法全部抽象定义，当我们对其进行二次开发的时，也会能快速定位到以前的和谐方法，然后进行快速定位和维护。</p><p>面向接口编程，还有一个很大的好处，就是可以降低类之间的耦合度。</p><h4 id="2-5、接口隔离原则"><a href="#2-5、接口隔离原则" class="headerlink" title="2.5、接口隔离原则"></a>2.5、接口隔离原则</h4><p>接口隔离原则的意思是：<strong>尽量将一个接口拆的更细，使用多个隔离的接口，比使用单个接口要好</strong>。</p><p>这个原则基本上是从大型软件架构出发、便于升级和维护的思想诞生出来的。</p><p>比如，一个第三方保险服务系统里面，如果是小项目，你可以在一个接口里面定义<code>投保方法</code>、<code>取消方法</code>、 <code>退保方法</code>、 <code>理赔方法</code>、 <code>保单方法</code>这5种方法。</p><p>当你只跟一家保险公司合作的时候，这套接口定义是没问题的，但是假如现在公司的业务发展的非常快，已经引入10几家保险公司了，你会发现这个接口基本上顶不住了，在此有两种方法可以解决这种技术难题：</p><ul><li>1、针对不同的保险公司，又重新定义一个接口，然后还是里面的5种方法</li><li>2、针对不同的操作行为，比如<code>投保</code>，单独定义一套接口，然后针对不同的保险公司编写不同的实现类</li></ul><p>这两种其实本质都是将一个接口，拆成多个颗粒度更细的接口，然后从行为上，让各种的实现类更加独立，进而降低类之间的耦合度，开发起来层次清晰，有利于系统的稳定！</p><h4 id="2-6、组合-聚合复用原则"><a href="#2-6、组合-聚合复用原则" class="headerlink" title="2.6、组合/聚合复用原则"></a>2.6、组合/聚合复用原则</h4><p>合成复用原则的意思就是：<strong>尽量使用组合/聚合的方式，而不是使用继承</strong>。</p><p>所谓<strong>组合/聚合的方式</strong>，其实就是我们在<code>springMVC</code>里面使用的<code>ioc</code>依赖注入方式，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AService</span> <span class="token punctuation">&#123;</span> <span class="token comment">/**     * ioc依赖注入     */</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">BService</span> bService<span class="token punctuation">;</span> <span class="token comment">//业务代码...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AService</code>类调用<code>BService</code>类，有两种方式可以实现，第一种就是通过继承方式，可以直接调用；第二种方式就是通过<code>ioc</code>依赖注入的方式，在类里面进行组合操作，然后进行调用。</p><p><strong>很明显，第二种方式，我们使用的爱不释手</strong>！</p><p>这种方式有个好处就是，代码层次清晰，编写优雅，用上之后容易上瘾，推荐使用！</p><h4 id="2-7、迪米特法则"><a href="#2-7、迪米特法则" class="headerlink" title="2.7、迪米特法则"></a>2.7、迪米特法则</h4><p>迪米特法则，又称最少知道原则，意思就是说：<strong>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</strong>。</p><p>类似单一原则的思想，例如我们编写实体类的时候，基本上就是属性名称，加<code>get/set</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span> <span class="token comment">/**     * 用户id     */</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> userId<span class="token punctuation">;</span> <span class="token comment">/**     * 用户姓名     */</span> <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userId<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserId</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>userId <span class="token operator">=</span> userId<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userName<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个实体里面出现跟自己没太大关系的代码时，例如数据运算逻辑处理，这个时候应当将这部分代码全部清理出去，交由业务处理层来出来。</p><p>从实体类的定义来说，它主要的功能就是承担数据展示，当多个业务处理层在使用这个实体类的时候，如果你们嵌套了很多的数据运算逻辑，可能在返回的时候，客户端得到的实体类的属性值，并不是正确的结果！</p><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>上面一共介绍了 7 种设计原则，基本上都是大神们经过很多次血的教训，总结出来的一套方法论。</p><p>这些设计原则，可以给同行在实际的软件设计过程中，提供一些思路，具体的应用，还需要结合实际的业务场景进一步思考，怎么让系统变的更加可靠，开发更佳迅速，代码阅读起来更佳轻松，关键在于灵活运用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解这些软件设计思想，你的思维至少上升一个段位！&quot;&gt;&lt;a href=&quot;#了解这些软件设计思想，你的思维至少上升一个段位！&quot; class=&quot;headerlink&quot; title=&quot;了解这些软件设计思想，你的思维至少上升一个段位！&quot;&gt;&lt;/a&gt;了解这些软件设计思想，你的思</summary>
      
    
    
    
    <category term="架构师" scheme="https://wangnaixing.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
    <category term="设计模式" scheme="https://wangnaixing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Markdown" scheme="https://wangnaixing.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Typora使用技巧——将图片自动上传到服务器上</title>
    <link href="https://wangnaixing.github.io/2021/12/05/Typora%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E5%B0%86%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <id>https://wangnaixing.github.io/2021/12/05/Typora%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E5%B0%86%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</id>
    <published>2021-12-05T01:25:00.000Z</published>
    <updated>2021-12-05T15:12:10.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora使用技巧——将图片自动上传到服务器上"><a href="#Typora使用技巧——将图片自动上传到服务器上" class="headerlink" title="Typora使用技巧——将图片自动上传到服务器上"></a>Typora使用技巧——将图片自动上传到服务器上</h1><h1 id="何为图床？"><a href="#何为图床？" class="headerlink" title="何为图床？"></a>何为图床？</h1><blockquote><p>说白了，就是类似百度网盘功能，放东西的，只不过这个东西都是图片！</p></blockquote><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205225519.jpg"></p><h1 id="PicGo-又是啥？"><a href="#PicGo-又是啥？" class="headerlink" title="PicGo 又是啥？"></a>PicGo 又是啥？</h1><p>PicGo是一种图床工具！就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 <code>Electron-vue</code> 开发的软件。</p><p>可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用</p><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205230208.jpg"></p><h1 id="Typora建立PicGo图床"><a href="#Typora建立PicGo图床" class="headerlink" title="Typora建立PicGo图床"></a>Typora建立PicGo图床</h1><blockquote><p>基于<code>Typora</code>+<code>Aliyun Oss对象存储</code>+<code>Picgo </code></p></blockquote><h2 id="1、阿里云图床"><a href="#1、阿里云图床" class="headerlink" title="1、阿里云图床"></a>1、阿里云图床</h2><p>首先在阿里云里搜索OSS，并开通服务。</p><p><strong>创建Bucket</strong></p><p>进入对象存储OSS，点击左侧栏Bucket 列表，创建Bucket 注意：读写权限选择<strong>公共读</strong>，不然PicGo无法上传图片。 </p><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205220521.jpg"></p><p>点击头像，创建<code>AccessKey</code>,保存相应的<code>AccessKey ID</code>和<code>Access Key Secret</code>信息。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">AccessKey</span> <span class="token attr-value">ID：LTAI5t8M5g7Fb4jKKyG7hcW2</span><span class="token attr-name">AccessKey</span> <span class="token attr-value">Secret：pKp1qfgwTObEBFeBpizTK3urK74RuH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、安装PicGo"><a href="#2、安装PicGo" class="headerlink" title="2、安装PicGo"></a>2、安装PicGo</h2><blockquote><p>下载网址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205221200.jpg"></p><p>然后安装。<strong>将PicGo的数据加入环境变量中。</strong></p><p>此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;双击Path-&gt;添加</p><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205222326.jpg"></p><h2 id="3、图床环境配置"><a href="#3、图床环境配置" class="headerlink" title="3、图床环境配置"></a>3、图床环境配置</h2><p>打开安装好的图床,进行配置，即可！</p><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205224027.jpg"></p><h2 id="4、Typora设置"><a href="#4、Typora设置" class="headerlink" title="4、Typora设置"></a>4、Typora设置</h2><p>设置自动上传到OSS阿里云，并且保存到我的笔记图片统一管理处（图片现在还是在本地）</p><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205224839-16387159733621.jpg"></p><p>手动上传</p><p><img src="https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/myblog/QQ%E6%88%AA%E5%9B%BE20211205225207.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Typora使用技巧——将图片自动上传到服务器上&quot;&gt;&lt;a href=&quot;#Typora使用技巧——将图片自动上传到服务器上&quot; class=&quot;headerlink&quot; title=&quot;Typora使用技巧——将图片自动上传到服务器上&quot;&gt;&lt;/a&gt;Typora使用技巧——将图</summary>
      
    
    
    
    <category term="Typora" scheme="https://wangnaixing.github.io/categories/Typora/"/>
    
    
    <category term="笔记" scheme="https://wangnaixing.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
